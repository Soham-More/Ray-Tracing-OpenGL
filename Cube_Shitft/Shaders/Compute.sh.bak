#version 430

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

uniform vec4 CameraPos;
uniform mat4 ViewTransform;

struct Ray
{
    vec3 Origin;
    vec3 Direction;
};

struct Plane
{
    vec3 Position;
    vec3 Normal;
};

struct Sphere
{
    vec3 Center;
    float Radius;
    vec4 Px_Color;
};

bool isIntersectingWithSphere(in Sphere sphere, in Ray ray)
{
    vec3 ray_o = ray.Origin;
	vec3 ray_d = ray.Direction;

	vec3 sphere_c = sphere.Center;
	float sphere_r = sphere.Radius;

	vec3 SphereRelativePos = sphere_c - ray_o;
	vec3 SphereDir = SphereRelativePos / length(SphereRelativePos);

	if(dot(SphereDir, ray_d) >= 0.0f)
	{
		float angle = dot(SphereDir, ray_d);
		float sinAngle = sqrt(1 - (angle * angle));

		float ShortestDist = sinAngle * length(SphereRelativePos);

		if(ShortestDist <= sphere_r)
		{
			return true;
		}
	}

	return false;
}

void main()
{
	// base pixel colour for image
	vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);

	// get index in global work group i.e x,y position
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	float max_x = 1.0f;
	float max_y = 1.0f;

	ivec2 dims = imageSize(img_output); // fetch image dimensions

	float x = (float(pixel_coords.x) / dims.x) - 0.5f;
	float y = (float(pixel_coords.y) / dims.y) - 0.5f;

	vec3 ray_o = CameraPos.xyz;
	vec3 ray_d = vec3(2.0f * x, 2.0f * y, -1.0);

	ray_d = ray_d / length(ray_d);

	ray_d = (vec4(ray_d, 0.0f) * ViewTransform).xyz;

	Ray r = { ray_o, ray_d };

	Sphere sp = { vec3(0.0, 0.0, -10.0), 1.0f, vec4(1.0f, 0.0f, 0.0f, 1.0f) };

    if(isIntersectingWithSphere(sp, r))
    {
        pixel = vec4(1.0f, 1.0f, 0.0f, 1.0f);
    }

	// output to a specific pixel in the image
	imageStore(img_output, ivec2(pixel_coords.x, pixel_coords.y), pixel);
}
